\documentclass[bachelor, och, coursework, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}


\usepackage[colorlinks=true]{hyperref}
%\usepackage[colorlinks=false]{hyperref}

% % %
\hypersetup{ hidelinks = true, }
% % %


\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Построение генератора SLR(1)-анализаторов ???}

% Курс
\course{3}

% Группа
\group{351}



% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
%\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Слуцкого Алексея Дмитриевича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н.} % степень, звание
\chname{С.\,В.\,Миронов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{Г.\,Г.\,Наркайтис}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{к.\,ф.-м.\,н., доцент}
\paname{Д.\,Ю.\,Петров}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{2}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
\duration{2}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{01.07.2016}
\practFinish{14.07.2016}

% Год выполнения отчета
\date{2017}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
%\abbreviations
%\begin{description}
%    \item $|A|$  "--- количество элементов в конечном множестве $A$;
%    \item $\det B$  "--- определитель матрицы $B$;
%    \item ИНС "--- Искусственная нейронная сеть;
%    \item FANN "--- Feedforward Artifitial Neural Network
%\end{description}

% Раздел "Определения". Может отсутствовать в работе
%\definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr


% Раздел "Введение"
\intro
Построение лексического и синтаксического анализаторов --- фундаментальная проблема в информационных технологиях. Построение анализаторов используется для решения широкого спектра задач: создание компиляторов, решение проблем распознавания речи, автоматизация обработки большого количества информации и многих других.

Существует множество программ, облегчающих создание анализаторов. Ярким примером этому служит связка утилит \verb|flex| и \verb|bison|. Они автоматически генерируют лексический и синтаксический анализаторы по заданному описанию грамматики. Большой интерес представляет построение собственного генератора.

В ходе данной курсовой работы будет написан генератор синтаксических анализаторов, в основе которого лежит алгоритм \verb|SLR(1)|-анализа. Программа получает на вход описание грамматики и возвращает файл с программой, написанной на языке $C$, осуществляющей вычисление алгебраического выражения согласно заданной грамматике.




\section{Восходящий синтаксический анализ}
\subsection{Синтаксический анализатор}
Синтаксический анализатор получает строку токенов от лексического анализатора, как показано на рис. \ref{ris:image1}, и проверяет, может ли эта строка имен токенов порождаться грамматикой исходного языка. Также от синтаксического анализатора ожидаются сообщения обо всех выявленных ошибках, причем достаточно внятных и полных, а кроме того, умения обрабатывать обычные, часто встречающиеся ошибки и продолжать работу с оставшейся частью программы. 

Концептуально в случае корректной программы синтаксический анализатор строит дерево разбора и передает его следующей части компилятора для дальнейшей обработки. В действительности явное построение дерева разбора не требуется, поскольку проверки и действия трансляции, могут выполняться в процессе синтаксического анализа. Таким образом, синтаксический анализатор и прочие части начальной стадии компилятора могут быть реализованы в виде единого модуля.~\cite{Kluch}

\begin{figure} [!ht]
	\centering
	\includegraphics[width=15cm]{img1_1.png}
	\caption{Место синтаксического анализатора в модели компилятора}
	\label{ris:image1}
\end{figure}






\subsection{Свертки}

Восходящий синтаксический анализ соответствует построению дерева  разбора для входной строки, начиная с листьев (снизу) и идя по направлению к корню (вверх). Синтаксический анализ отчасти заключается в построении дерева разбора, хотя начальная стадия компиляции может в действительности быть  выполнена и без явного построения дерева.

Можно рассматривать восходящий синтаксический анализ как процесс  <<свертки>> строки $w$ к стартовому символу грамматики. На каждом шаге свертки (reduction) определенная подстрока, соответствующая телу продукции, заменяется нетерминалом из заголовка этой продукции. Действие свертки включает изменения на вершине стека и в сентенциальной форме. В начале синтаксического анализа сентенциальная форма --- это в точности читаемое предложение, а стек пуст; в конце синтаксического анализа сентенциальная форма --- это символ предложения, строка прочитана, а стек содержит только символ предложения.~\cite{Karpov}

Необходимым условием действия свертки является наличие правой части некоторой продукции на вершине стека, в противном случае производится перенос, и на вершине стека появится следующий символ. В то же время появление правой части продукции на вершине стека не является достаточным условием для применения свертки. Ключевые решения, принимаемые в процессе восходящего синтаксического анализа, --- когда выполнять свертку и какую продукцию применять.

В строке символов на вершине стека возможно будут определены правые части более одной продукции, так что на определенном этапе синтаксического анализа могут существовать две или более возможных свертки. Итак, если в определенный момент кажутся возможными действия свертки и переноса, говорят, что имеет место конфликт перенос/свертка (shift-reduce conflict). Если возможными кажутся несколько операций свертки, говорят, что имеет место конфликт свертка/свертка (reduce-reduce conflict). С целью выработки детерминированного метода синтаксического анализа могут применяться различные стратегии разрешения названных конфликтов.~\cite{myshared}

На практике данные конфликты разрешаются с использованием следующей информации (один пункт или оба):
\begin{itemize}
	\item предшествующая история синтаксического анализа;
	\item информация, полученная путем предпросмотра.
\end{itemize}

По определению свертка представляет собой шаг, обратный порождению  
(в порождении нетерминал в сентенциальной форме замещается телом 
одной из его продукций). Цель восходящего синтаксического анализа, таким  
образом, состоит в построении порождения в обратном порядке.~\cite{Kluch}

\subsection{Обрезка основ}

Восходящий синтаксический анализ в процессе сканирования входного  
потока слева направо строит правое порождение в обратном порядке. Неформально 
говоря, основа, или дескриптор (handle), строки — это подстрока, которая  
соответствует телу продукции и свертка которой представляет собой один шаг правого 
порождения в обратном порядке. 

Формально, если $S \Rightarrow aAw \Rightarrow a\beta w$, то продукция $A \to \beta$ в позиции после $a$ является <<основой>> (handle) $a\beta w$. В качестве альтернативы основой правосентенциальной формы $\gamma$ является продукция $A \to \beta$ и позиция $\gamma$, в которой может быть найдена строка $\beta$ такая, что замена $\beta$ в данной позиции на $A$ дает предшествующую правосентенциальную форму в правом порождении $\gamma$.~\cite{Compilers}

Строка $w$ справа от основы должна содержать только терминальные символы. При этом грамматика может быть неоднозначной, с несколькими правыми порождениями $a\beta w$. Если грамматика однозначна, то каждая правосентенциальная форма грамматики имеет ровно одну основу. 

Обращенное правое порождение может быть получено посредством <<обрезки основ>>. Процесс начинается со строки терминалов $w$, которую необходимо проанализировать. Если $w$ --- предложение рассматриваемой грамматики, то $w = \gamma_n$, где $\gamma_n$ --- $n$-я правосентенциальная форма некоторого еще неизвестного правого порождения $S = \gamma_0 \Rightarrow \gamma_1 \Rightarrow ... \Rightarrow \gamma_{n-1} \Rightarrow \gamma_n = w$.
 
Для воссоздания этого порождения в обратном порядке находится основа $\beta_n$ в $\gamma_n$ и заменяется ее левой частью продукции $A_n \to \beta_n$ для получения предыдущей правосентенциальной формы $\gamma_{n-1}$.

Затем повторяется описанный процесс, т.е. находится в $\gamma_{n-1}$ основа $\beta_{n-1}$ и свертывается для получения правосентенциальной формы $\gamma_{n-2}$. Если после очередного шага правосентенциальная форма содержит только стартовый символ $S$, процесс прекращается и сообщается об успешном завершении анализа.  
Обращенная последовательность продукций, использованных в свертках, представляет 
собой правое порождение входной строки.~\cite{Sereb}




\subsection{Синтаксический анализ <<перенос/свертка>> }

Синтаксический анализ <<перенос/свертка>> (ПС-анализ) представляет собой разновидность восходящего анализа, в котором для хранения символов грамматики используется стек, а для хранения оставшейся непроанализированной части входной строки --- входной буфер. Для маркирования дна стека и правого конца входной строки используется символ \$. Изначально стек пуст, а во входном буфере находится 
строка $w$.

В процессе сканирования входной строки слева направо синтаксический анализатор выполняет нуль или несколько переносов символов в стек, пока не будет готов выполнить свертку строки $\beta$ символов грамматики на вершине стека. Затем он выполняет свертку $\beta$ к заголовку соответствующей продукции. Синтаксический анализатор повторяет этот цикл до тех пор, пока не будет обнаружена ошибка или пока стек не будет содержать только стартовый символ, а входной буфер будет при этом пуст. Достигнув указанной конфигурации, синтаксический анализатор останавливается и сообщает об успешном завершении анализа. 

Хотя основными операциями являются перенос и свертка, всего ПС-анализатор может выполнять четыре действия: 
\begin{enumerate}
    \item \textit {Перенос} (shift). Перенос очередного входною символа на вершину стека. 
    \item \textit {Свертка} (reduce). Правая часть сворачиваемой строки должна располагаться на вершине стека. Определяется левый конец строки в стеке и принимается решение о том, каким нетерминалом будет заменена строка. 
    \item \textit {Принятие} (accept). Объявление об успешном завершении синтаксического анализа. 
    \item \textit {Ошибка} (error). Обнаружение синтаксической ошибки и вызов подпрограммы восстановления после ошибки. 
\end{enumerate}

Использование стека в ПС-анализаторе объясняется тем важным фактом, что 
основа всегда находится на вершине стека и никогда — внутри него. Это можно 
показать путем рассмотрения возможных видов двух последовательных шагов 
в любом правом порождении:
\begin{enumerate}
    \item $S \Rightarrow aAz \Rightarrow a\beta Byz \Rightarrow a\beta \gamma yz$
    \item $S \Rightarrow aBxAz \Rightarrow aBxyz \Rightarrow a\gamma xyz$
\end{enumerate}



В обоих случаях после выполнения свертки синтаксический анализатор должен 
один или несколько раз перенести символы для получения в стеке очередной 
основы. Он никогда не должен углубляться в ее поисках в стек.~\cite{Sokolov}


\section{Реализация простого LR-анализа}
\subsection{Преимущества использования LR-анализаторов}
LR-анализаторы управляются таблицами. Грамматика, для которой можно построить таблицу восходящего синтаксического анализа, называется LR-грамматикой. Для того, чтобы грамматика была LR-грамматикой, достаточно, чтобы синтаксический анализатор,  работающий слева направо методом переноса/свертки, был способен распознавать основы правосентенциальных форм при их появлении на вершине стека. 
LR-анализ полезен и удобен по множеству причин:
\begin{itemize}
	\item LR-анализаторы могут быть созданы для распознавания практически всех конструкций языков программирования, для которых может быть написана контекстно-свободная грамматика. Контекстно-свободные грамматики, не являющиеся LR-грамматиками, существуют, однако для типичных конструкций языков программирования их вполне можно избежать.
	\item Метод LR-анализа --- наиболее общий метод ПС-анализа без возврата, который, кроме того, не уступает в эффективности другим, более примитивным ПС-методам.
	\item LR-анализатор может обнаруживать синтаксические ошибки сразу же, как только это становится возможным при сканировании входного потока. 
	\item Класс грамматик, которые могут быть проанализированы с использованием LR-методов, представляет собой надмножество класса грамматик, которые могут быть проанализированы с использованием предиктивных или LL-методов синтаксического анализа. В случае грамматик, принадлежащих классу LR($k$), возникает необходимость распознать правую часть продукции в порожденной ею правосентенциальной форме с дополнительным предпросмотром $k$ входных символов. Это требование существенно мягче требования для LL($k$)-грамматик, в которых необходимо распознать продукцию по первым к символам порождения ее тела. Таким образом становится ясно, что LR-грамматики могут описать существенно больше языков, чем LL-грамматики. 
\end{itemize}

Основной недостаток LR-метода состоит в том, что построение LR-анализатора для грамматики типичного языка программирования вручную требует очень большого объема работы. Для решения этой задачи нужен специализированный инструмент --- генератор LR-анализаторов. К счастью, имеется множество таких генераторов. К наиболее широко используемым относят Yacc и Bison. Такой генератор получает контекстно-свободную грамматику и автоматически строит ее синтаксический анализатор. Если грамматика содержит неоднозначности или другие конструкции, трудные для синтаксического анализа сканированием входного потока слева направо, генератор локализует их и предоставляет детальную диагностическую информацию.~\cite{Sereb}



\subsection{Пункты}
\subsubsection{Множества пунктов}
Каким образом ПС-анализатор выясняет, когда следует выполнять перенос, а когда --- свертку? LR-анализатор принимает решение о выборе <<перенос/свертка>>, поддерживая состояния, которые отслеживают, где именно в процессе синтаксического анализа мы находимся. Состояния представляют собой множества <<пунктов>>. LR(0)-пункт грамматики $G$ --- это продукция $G$ с точкой в некоторой позиции правой части. Следовательно, продукция $A \to XYZ$ дает четыре пункта: 
\[
	A \to \cdot XYZ 
\]
\[
	A \to X\cdot YZ 
\]
\[
	A \to XY\cdot Z 
\]
\[
	A \to XYZ\cdot
\]
 
Продукция $A \to \epsilon$ генерирует единственный пункт $A \to \cdot$. 

Образно говоря, пункт указывает, какая часть продукции уже просмотрена в данной точке в процессе синтаксического анализа. Например, пункт $A \to \cdot XYZ$ указывает, что во входном потоке ожидается строка, порождаемая $XYZ$. Пункт $A \to X\cdot YZ$ указывает, что уже просмотрена строка, порожденная $X$, и ожидается из входного потока строка, порождаемая $YZ$. Пункт $A \to XYZ\cdot$ говорит о том, что уже обнаружено тело $XYZ$ и что, возможно, пришло время свернуть $XYZ$ в $A$.~\cite{Compilers}

Один набор множеств LR(0)-пунктов, именуемый каноническим набором 
LR(0), обеспечивает основу для построения детерминированного конечного  
автомата, который используется для принятия решений в процессе синтаксического 
анализа. Такой автомат называется LR(0)-автоматом. В частности, каждое  
состояние LR (0)-автомата представляет множество пунктов в каноническом наборе 
LR(0). 

Для построения канонического LR(0)-нaбopa определяется расширенная грамматика и две функции, \verb|CLOSURE| и \verb|GOTO|. Если $G$ --- грамматика со стартовым символом $S$, то расширенная грамматика $G'$ представляет собой $G$ с новым стартовым символом $S'$ и продукцией $S' \to S$. Назначение этой новой стартовой продукции --- указать синтаксическому анализатору, когда следует прекратить анализ и сообщить о принятии входной строки; т.е. принятие осуществляется тогда и только тогда, когда синтаксический анализатор выполняет свертку с использованием продукции $S' \to S$.~\cite{Karpov}

\subsubsection{Замыкание множеств пунктов}

Если $I$ --- множество пунктов грамматики $G$, то \verb|CLOSURE|($I$) представляет собой множество пунктов, построенное из $I$ согласно двум правилам:
\begin{itemize}
	\item Изначально в \verb|CLOSURE|($I$) добавляются все пункты из $I$. 
	\item Если $A \to a \cdot B\beta$ входит в \verb|CLOSURE|($I$), а $B \to \gamma$ является продукцией, то в \verb|CLOSURE|($I$) добавляется пункт $B \to \cdot \gamma$, если его там еще нет. Это правило применяется до тех пор, пока не останется пунктов, которые могут быть добавлены в \verb|CLOSURE|($I$).
\end{itemize}

$A \to a \cdot B\beta$ в \verb|CLOSURE|($I$) указывает, что в некоторой точке процесса синтаксического анализа полагается, что далее во входной строке возможно встретить подстроку, порождаемую из $B\beta$. Подстрока, порождаемая из $B\beta$, будет иметь префикс, порождаемый из $B$ путем применения одной из $B$-продукций. Таким образом,  добавляются пункты для всех $B$-продукций. 

Множество пунктов можно разделить на два класса: 
\begin{itemize}
	\item Базисные пункты, или пункты ядра (kernel items): начальный пункт \linebreak 
	$S' \to \cdot S$ и все пункты, у которых точки расположены не у левого края. 
	\item Небазисные (nonkernel) пункты, у которых точки расположены слева, за исключением $S' \to \cdot S$. 
\end{itemize}
Кроме того, каждое множество пунктов формируется как замыкание множества базисных пунктов; добавляемые в замыкание пункты не могут быть базисными. Таким образом, можно представить множества пунктов с использованием очень небольшого объема памяти, если отбросить все небазисные пункты, зная, что они могут быть восстановлены процессом замыкания.~\cite{Sokolov}

\subsubsection{Функция GOTO}

Второй полезной функцией является \verb|GOTO|($I$, $X$), где $I$ — множество пунктов, а $X$ --- грамматический символ. \verb|GOTO|($I$, $X$) определяется как замыкание множества всех пунктов $A \to aX\cdot \beta$ таких, что $A \to a\cdot X\beta$ находится в $I$. Функция \verb|GOTO| используется для определения переходов в LR(0)-автомате грамматики. Состояния автомата соответствуют множествам пунктов, и \verb|GOTO|($I$, $X$) указывает переход из состояния $I$ при входном символе $X$. 

\subsubsection{Использование LR(0)-автомата }

Основная идея, лежащая в основе <<простого LR>>, или SLR, синтаксического анализа заключается в построении LR(0)-автомата для заданной грамматики. Состояниями этого автомата являются множества пунктов из канонического набора LR(0), а переходы определяются функцией \verb|GOTO|. 

Стартовое состояние LR(0)-автомата --- \verb|CLOSURE|({[$S' \to \cdot S$]}), где $S'$ --- стартовый символ расширенной грамматики. Все состояния являются принимающими. Под состоянием $j$ подразумевается состояние, соответствующее множеству пунктов $I_j$. 

Каким образом LR(0)-автомат помогает в принятии решения \linebreak <<перенос/свертка>>? Это решение может быть принято следующим образом. Пусть строка $\gamma$ из символов грамматики переводит LR(0)-автомат из состояния 0 в некоторое состояние $j$. Тогда если состояние $j$ имеет переход для очередного входного символа $a$, выполняется перенос данного символа $a$. В противном случае выбирается свертка; пункт в состоянии $j$ определяет, какую продукцию следует для этого использовать.~\cite{Sereb}

Алгоритм LR-анализа использует стек для отслеживания как состояний, так и символов грамматики; фактически символы грамматики могут быть восстановлены из состояний, так что стек хранит только состояния.

\subsection{Алгоритм LR-анализа }

Схематически LR-анализатор показан на рис. \ref{ris:image2}. Он состоит из входного буфера, выхода, стека, программы-драйвера и таблицы синтаксического анализа, состоящей из двух частей (\verb|ACTION| и \verb|GOTO|). Программа-драйвер одинакова для всех LR-анализаторов; от одного анализатора к другому меняются таблицы  синтаксического анализа. Программа синтаксического анализа по одному считывает символы из входного буфера. Там, где ПС-анализатор должен перенести символ, LR-анализатор переносит состояние. Каждое состояние подытоживает информацию, содержащуюся в стеке ниже него.
 
\begin{figure} [!ht]
	\centering
	\includegraphics[width=15cm]{img2.png}
	\caption{Модель LR-анализатора}
	\label{ris:image2}
\end{figure}

Стек хранит последовательность состояний $s_0s_1...s_m$, где $s_m$ находится на вершине стека. В случае метода SLR стек хранит состояния LR(0) -автомата; В соответствии с построением каждое состояние имеет соответствующий грамматический символ. Так как состояния соответствуют множествам пунктов, то существует переход из состояния $i$ в состояние $j$, если \verb|GOTO|($I_i$, $X$) = $I_j$. Все переходы в состояние $j$ должны соответствовать одному и тому же символу грамматики $X$. Таким  образом, каждое состояние, за исключением стартового состояния 0, имеет единственный грамматический символ, связанный с ним.~\cite{Kluch}

Таблица синтаксического анализа состоит из двух частей: функции действий синтаксического анализа \verb|ACTION| и функции переходов \verb|GOTO|:
\begin{enumerate}
	\item Функция \verb|ACTION| принимает в качестве аргумента состояние $i$ и терминал	$a$ (или \$, маркер конца входной строки). Значение \verb|ACTION|[$i$, $a$] может быть 
	одного из следующих видов:
	\begin{itemize}
		\item Перенос $j$, где $j$ --- состояние. Действие, предпринимаемое синтаксическим анализатором, эффективно переносит входной символ $a$ в стек, но для представления $a$ использует состояние $j$. 
		\item Свертка $A \to \beta$. Действие синтаксического анализатора состоит в эффективной свертке $\beta$ на вершине стека в заголовок $A$.
		\item Принятие. Синтаксический анализатор принимает входную строку и завершает анализ. 
		\item Ошибка. Синтаксический анализатор обнаруживает ошибку во входной строке и предпринимает некоторое корректирующее действие.
	\end{itemize}
	\item Функция \verb|GOTO|, определенная на множествах пунктов, распространяется на состояния: если \verb|GOTO|[$I_i$, $A$] = $I_j$, то \verb|GOTO| отображает также состояние $i$ и нетерминал $A$ на состояние $j$. 
\end{enumerate}


Описать поведение LR-анализатора можно с помощью обозначений, представляющих полное состояние синтаксического анализатора: его стек и оставшуюся непроанализированной часть входной строки. Конфигурация \linebreak 
LR-анализатора представляет собой пару 
\[
	(s_0...s_m, a_i...a_n\$) 
\]
Здесь первый компонент --- содержимое стека (вершина стека справа), а второй 
компонент --- оставшаяся непроанализированной часть входной строки. Эта  
конфигурация представляет правосентенциальную форму 
\[
	X_1...X_ma_i...a_n
\]
тем же способом, что и ПС-анализатор; единственное отличие заключается в том, что вместо символов грамматики в стеке хранятся состояния, из которых могут быть восстановлены грамматические символы. Иначе говоря, $X_i$ является грамматическим символом, представленным состоянием $s_i$. При этом стартовое состояние синтаксического анализатора $s_0$ не представляет символ грамматики, а служит маркером дна стека и играет важную роль в процессе анализа. 


Очередной шаг синтаксического анализатора из приведенной выше конфигурации определяется считанным текущим входным символом $a_i$ и состоянием на вершине стека $s_m$ путем обращения к записи \verb|ACTION|[$s_m$, $a_i$] в таблице действий синтаксического анализа. В результате выполнения указанного в записи действия (одного из четырех возможных типов) получаются следующие конфигурации:
\begin{enumerate}
	\item Если \verb|ACTION|[$s_m$, $a_i$] = перенос $s$, синтаксический анализатор выполняет перенос в стек очередного состояния $s$ и его конфигурацией становится 
	\[
			(s_0...s_ms, a_{i+1}...a_n\$) 
	\]
	Символ $a_i$ хранить в стеке не нужно, поскольку при необходимости он может быть восстановлен из $s$. Текущим входным символом становится $a_{i+1}$.
	\item Если \verb|ACTION|[$s_m$, $a_i$] = свертка $A \to \beta$, синтаксический анализатор выполняет свертку и его конфигурацией становится 
	\[
			(s_0...s_{m-r}s, a_ia_{i+1}...a_n\$) 
	\]
	Здесь $r$ --- длина $\beta$, а $s$ = \verb|GOTO|[$s_{m-r}$, $A$]. Синтаксический анализатор вначале снимает $r$ символов состояний с вершины стека, что переносит на вершину стека состояние $s_{m-r}$, после чего на вершину стека помещается $s$, запись из \verb|GOTO|[$s_{m-r}$, $A$]. При свертке текущий входной символ не изменяется. 
	\item Если \verb|ACTION|[$s_m$, $a_i$] = принятие, синтаксический анализ завершается. 
	\item Если \verb|ACTION|[$s_m$, $a_i$] = ошибка, синтаксический анализатор обнаруживает ошибку и вызывает подпрограмму восстановления после ошибки. 
\end{enumerate}

Все LR-анализаторы ведут себя подобным образом; единственное отличие одного LR-анализатора от другого заключается в информации в записях полей \verb|ACTION| и \verb|GOTO| таблицы синтаксического анализа.~\cite{Compilers}


\subsection{Построение таблиц SLR-анализа }

SLR-метод начинается с LR(0)-пунктов и LR(0)-автомата. Для данной грамматики $G$ строится ее расширение $G'$ с новым стартовым символом $S'$. Для $G'$ строится канонический набор $C$ множеств пунктов $G'$ вместе с функцией \verb|GOTO|. 

Затем строятся записи \verb|ACTION| и \verb|GOTO| в таблице синтаксического анализа с  использованием следующего алгоритма:
\begin{enumerate} 
	\item Строится $C$ = \{$I_0...I_n$\} — набор множеств LR(0)-пунктов для $G'$. 
	\item Из $I_i$ строится состояние $i$. Действие синтаксического анализа для состояния $i$ определяется следующим образом:
	\begin{itemize}
		\item Если [$A \to \alpha \cdot a\beta$] $\in I_i$ и \verb|GOTO|($I_i$, $a$) = $I_j$, то устанавливается \linebreak
		\verb|ACTION|[$i$, $a$] равным <<перенос $j$>>. Здесь $a$ должно быть терминалом. 
		\item Если [$A \to \alpha \cdot$] $\in I_i$, то устанавливается \verb|ACTION|[$i$, $a$] равным <<свертка $A \to \alpha$>> для всех $a$ из \verb|FOLLOW|($A$); здесь $A$ не должно быть равно $S'$. 
		\item Если [$S' \to S \cdot$] $\in I_i$, то устанавливается \verb|ACTION|[$i$, \$] равным <<принятие>>. 
	\end{itemize}
	При наличии любого конфликта между действиями, возникшего в результате применения указанных правил, делается вывод о том, что грамматика не принадлежит классу SLR(1). В таком случае алгоритм не может построить синтаксический анализатор для данной грамматики. 
	\item Переходы для состояния $i$ строятся для всех нетерминалов $A$ с  использованием следующего правила: если \verb|GOTO|($I_i$, $A$) = $I_j$, то \verb|GOTO|($i$, $A$) = $j$.
	\item Все записи, не определенные правилами 2 и 3, получают значение <<ошибка>>. 
	\item Начальное состояние синтаксического анализатора строим из множества пунктов, содержащего [$S' \to \cdot S$]. 
\end{enumerate}



\section{Пример реализации генератора SLR-анализаторов}
\subsection{Построение анализатора}
Реализуем сначала алгоритм LR-анализа, при условии, что необходимые таблицы \verb|ACTION| и  \verb|GOTO| уже имеются в исходном коде. 

Для хранения состояний автомата заведем стек \verb|state|, для хранения данных о токенах ---  стек \verb|result|. Так как нет необходимости просматривать более одного токена наперед, будем вычитывать каждый следующий токен только тогда, когда в этом есть необходимость. Это можно реализовать с помощью \verb|Flex|. 

Пусть лексический анализатор записывает в переменную \verb|yylval| распознанное число (Приложение \ref{pril-scanner}), а возвращает \verb|item_t|, согласно \verb|values.h| (строки 4-18 приложения \ref{pril-values}).

Для простоты реализации вся необходимая информация хранится в одной структуре --- \verb|table|, причем \verb|ACTION| и \verb|GOTO| объединены в один двумерный массив.

В строках 51-77 приложения \ref{pril-myLR} бесконечный цикл, который описывает работу LR-автомата. Сначала в переменную \verb|cur_state| складывается верхнее значение стека и определяется текущее действие, согласно таблице переходов. Далее следует \verb|switch| по этому действию. Это может быть сдвиг, перенос, принятие или ошибка.~\cite{Sokolov}

Каждый новый токен вычитывается с помощью \verb|Flex| только при выполнении действий с \verb|AC_SHIFT|, посредством вызова функции \verb|yylex|. В случае, если требуется выполнить свертку некоторой грамматики, необходимые действия над стеком значений выполняет функция \verb|apply| (строки 11-35 приложения \ref{pril-myLR}).

Таким образом, имея в распоряжении только лишь \verb|table|, можно осуществить разбор выражения, согласно заданной грамматике.

Полный код программы \verb|myLR.c| находится в приложении \ref{pril-myLR}.


\subsection{Построение генератора}
Из предыдущего параграфа следует, что от программы-генератора ожидается переменная \verb|table|, с помощью которой будет работать автомат. Каким образом программа \verb|follow.c| передаст эту переменную программе \verb|myLR.c|? Пусть \verb|follow.c| выведет всю информацию о \verb|table| в отдельный файл (Приложение \ref{pril-build}), а в программе \verb|myLR.c| просто выполним текстовую подстановку при инициализации переменной \verb|table| из сгенерированного файла (строки 81-84 приложения \ref{pril-myLR}).

Для построения LR-автомата необходимо знать функцию \verb|FOLLOW| для каждого нетерминального символа. В свою очередь для подсчета \verb|FOLLOW| нужна функция \verb|FIRST|. Поэтому сначала насчитаем эти две функции и запишем результат в переменные \verb|first| и \verb|follow| соответственно (строки 524-559 приложения \ref{pril-follow}).

Будем подсчитывать множества \verb|first| и \verb|follow| рекурсивно. При этом чтобы не вычислять никакое множество дважды, заведем массив \verb|used|, который будет хранить информацию о каждом токене:
\begin{itemize}
	\item \verb|NOT_COUNTED|, если \verb|first| для этого токена еще не посчитан.
	\item \verb|IN_PROGRESS|, если для подсчета \verb|first| текущего токена $A$ нужен \verb|first| другого токена, который также зависит от $A$. Очевидно, что в данном случае грамматика не является SLR-грамматикой и дальнейшие подсчеты не имеют смысла.
	\item \verb|COUNTED|, если \verb|first| для этого токена уже считался и им можно воспользоваться.
\end{itemize}

То же самое сделаем для \verb|follow|.

Построим теперь граф SLR-автомата. Для этого понадобятся две структуры:
\begin{itemize}
	\item \verb|graph|, для хранения переходов из одного состояния в другое по некоторому входному токену;
	\item \verb|scheme|, для хранения множества пунктов в каждом состоянии автомата.
\end{itemize}

Нулевое состояние всегда будет содержать пункт $S' \to .E$, из которого получается все множество пунктов с помощью функции \verb|add_points|. Она проверяет, есть ли в множестве пунктов продукции, содержащие точку перед текущим токеном, и для каждой такой продукции добавляет новые пункты, если они еще не добавлялись. Это отслеживается посредством массива \verb|added| (строки 201-242 приложения \ref{pril-follow}).

Далее для всех на текущий момент насчитанных состояний автомата попытаемся выполнить переход по каждому терминальному и нетерминальному символу (строки 269-291 приложения \ref{pril-follow}). Когда базовые пункты получены, посмотрим, есть ли еще нужные пункты с помощью той же функции \verb|add_points|. 

Теперь, когда собрано новое состояние, проверим, не совпадает ли оно с уже имеющимся состоянием. Если не совпадает, то добавим его в \verb|graph| и \verb|scheme| (строки 293-309 приложения \ref{pril-follow}).

Граф построен. Осталось только заполнить таблицу действий для каждого состояния и каждого входного токена. Первоначально проинициализируем ее \verb|AC_ERROR|. Далее пройдем по каждому пункту \verb|scheme|. Для каждой продукции возможны три случая:
\begin{enumerate}
	\item Правило с точкой на конце, и в левой части стоит $S'$: в соответствующую ячейку ставим \verb|AC_ACCEPT|.
	\item Правило с точкой на конце, и в левой части не $S'$: в соответствующую ячейку записываем действие \verb|AC_REDUCE| и номер грамматики.
	\item Правило без точки на конце: в соответствующую ячейку записываем действие \verb|AC_SHIFT| и номер следующего состояния.
\end{enumerate}

Когда все необходимые \verb|myLR.c| данные получены, вывод информации в специальном формате осуществляет функция \verb|write_tables| (строки 394-440 приложения \ref{pril-follow}).

Полный код программы \verb|follow.c| находится в приложении \ref{pril-follow}.










% Раздел "Заключение"
\conclusion
Целью данной курсовой работы было изучить теоретическую часть построения LR-анализаторов и разработать генератор синтаксических SLR-анализаторов. Было реализовано приложение, выполняющее синтаксический разбор выражений по заданной грамматике.

В ходе выполнения курсовой работы были изучены и отработаны навыки по следующим темам:
\begin{itemize}
	\item алгоритм работы синтаксического анализатора;
	\item работа с \verb|GNU Linux|;
	\item работа с \verb|Makefile|;
	\item восходящий синтаксический анализ;
	\item построение таблиц SLR-анализа;
	\item написание программ на языке $C$;
	\item формальные грамматики
\end{itemize}




%Библиографический список, составленный вручную, без использования BibTeX
%
%\begin{thebibliography}{99}
%  \bibitem{Ione} Источник 1.
%  \bibitem{Itwo} Источник 2
%\end{thebibliography}

%Библиографический список, составленный с помощью BibTeX
%
\bibliographystyle{gost780uv}
\bibliography{thesis}

% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением
\appendix

\section{Листинг программы <<values.h>>}\label{pril-values}
\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{values.txt}

\section{Листинг программы <<Makefile>>}\label{pril-make}
\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{Makefile.txt}

\section{Листинг программы <<follow.c>>}\label{pril-follow}
\VerbatimInput[tabsize=4, fontsize=\small, numbers=left, numbersep=2pt]{follow.txt}

\section{Листинг программы <<scanner.l>>}\label{pril-scanner}
\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{scanner.txt}

\section{Листинг программы <<myLR.c>>}\label{pril-myLR}
\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{myLR.txt}

\section{Листинг программы <<build\textunderscore result.txt>>}\label{pril-build}
\VerbatimInput[fontsize=\small, numbers=left, numbersep=2pt]{build_result.txt}






\end{document}
